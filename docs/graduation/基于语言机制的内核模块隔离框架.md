# 现有的研究
- 基于硬件的隔离
能够实现强隔离，成本高，灵活性差，引入性能开销（上下文切换）。

- 基于软件的隔离
    - 插入边界检查：损失性能，需要人为指定被保护模块。
    - 微内核架构：精简内核，将大部分功能移到用户态。但是由于IPC需要频繁内核态与用户态切换，性能开销较大。

- 基于传统安全语言的隔离
    - 基于GC语言（Go, C#）：内存安全，但是GC引入性能开销，且需要修改运行时或者使用其它语言才能与硬件交互。
    - 基于Rust语言：内存安全，零成本抽象，有些工作没能明确划分safe/unsafe, 有些工作没考虑热升级，大部分工作是从头写一个操作系统，而不是改造现有的操作系统。

- 热升级
    - 功能级别热升级：只能升级简单功能，不能升级接口/依赖复杂的模块。
    - 组件级别热升级：需要保证升级前后状态一致，同时尽量减少停机时间。现有的研究难以移植到商用操作系统。

# Moat
- 基于Rust语言的隔离
- 分为可信计算基（TCB）和域集合
    - TCB：包含域管理运行时与域基础库，集成所有unsafe代码，提供基础内核资源服务，实现域的隔离和热加载。
    - 域集合：仅包含safe代码。

域集合:
- 私有堆：进行内存隔离, 放置域私有数据结构。
- 共享堆：所有域共享，用于域间通信。
- 自定义堆：存储状态，用于热升级，需要与私有堆区分。

域基础库:
- 提供域管理运行时的接口
- 提供私有堆、共享堆、自定义堆的堆分配接口
- 封装锁，内存访问，指针等功能，保证安全性

域管理运行时:
- 域的注册、创建与销毁
- 域的物理内存管理
- 域的自定义堆管理
- 随操作系统一同初始化，然后加载若干必要的域

域间通信
- 强制使用共享堆上的`DBox<T>`类型
- 通过`DBox<T>`记录数据的域所有权，在域卸载时回收
- 仅允许通过不可变引用或所有权传递
```Rust
pub trait BlkDeviceDriver: DeviceBase + Basic + DowncastSync {
    fn read_block(block: u32, data: &mut [u8])-> Result<usize>;
    fn write_block(block: u32, data: &[u8])-> Result<usize>;
}
```
转变为
```Rust
pub trait BlkDeviceDomain: DeviceBase + Basic + DowncastSync {
    fn init(device: &Range<usize>)-> Result<()>;
    fn read_block(block: u32, data: DVec<u8>)-> Result<DVec<u8>>;
    fn write_block(block: u32, data: &DVec<u8>)-> Result<usize>;
}
```
(为啥read_block还要传入一个data参数?即使指定长度也可以直接传入一个`DBox<usize>`)

故障隔离
- 通过Rust编译选项`unwind`使得`panic`时执行栈展开
- 为所有内核资源实现`Drop` trait，在panic时释放资源, 避免资源泄露或死锁等
- 不能解决所有故障, 但是这些故障的责任不在故障隔离功能
- 通过域代理捕获域故障，保持原来的接口，在Err中返回域错误
```Rust
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    if let Some(p) = info.location() {
        println!("line {}, file {}: {}", p.line(), p.file(), info.message());
    } else {
        println!("no location information available");
    }
    #[cfg(feature = "rust-unwind")]
    {
        unwinding::panic::begin_panic(Box::new(()));
        // drop(guard);
    }
    system_shutdown();
}

pub fn catch_unwind<F: FnOnce() -> AlienResult<R>, R>(f: F) -> AlienResult<R> {
    let res = unwinding::panic::catch_unwind(f).unwrap_or_else(|_| {
        println_color!(31, "catch unwind error");
        Err(AlienError::DOMAINCRASH)
    });
    res
}
```

热升级
- 自定义堆提供键值对的存储和查询接口
- 域分为有状态域和无状态域
- 无状态域更新:RCU方式，加载新版本域并改变指向，之后等待所有旧版本域调用结束后卸载旧版本域
- 有状态域更新:为每个域设置一个标记，表示当前域是否正在进行热升级。若否则进入快速调用路径，仅增加/减少计数器；若是则进入慢速调用路径，获取锁，等待热升级完成再调用域函数。为避免在读者增加计数器前开始热更新，通过开关中断，更新者通过中断确定每个读者已经完成调用。
- 通过域代理封装更新实现
```Rust
fn gen_trampoline_rwlock(arg: TrampolineArg) -> (TokenStream, TokenStream) {
    let TrampolineArg {
        has_recovery,
        trait_name,
        proxy_name: _,
        func_name,
        input_argv,
        fn_args,
        arg_domain_change,
        out_put,
        no_check,
    } = arg;

    let info = gen_trampoline_info(&arg_domain_change, no_check);

    let (inner_call_code, __ident_no_lock, __ident_with_lock) = impl_inner_code(
        has_recovery,
        (&func_name, trait_name),
        &fn_args,
        &input_argv,
        out_put,
        &arg_domain_change,
        &info,
    );

    // let ident_key = Ident::new(
    //     &format!("{}_KEY", proxy_name.to_string().to_uppercase()),
    //     proxy_name.span(),
    // );
    let call = quote!(
        if self.flag.load(core::sync::atomic::Ordering::SeqCst) {
            return self.#__ident_with_lock(#(#input_argv),*);
        }
        self.#__ident_no_lock(#(#input_argv),*)
    );
    // println!("{:?}",real_code.to_string());
    (call, inner_call_code)
}

fn impl_inner_code(
    _has_recover: bool,
    func_trait_name: (&Ident, &Ident),
    fn_argv: &Vec<FnArg>,
    input_argv: &Vec<Ident>,
    output: ReturnType,
    arg_domain_change: &Vec<TokenStream>,
    info: &TrampolineInfo,
) -> (TokenStream, Ident, Ident) {
    let (func_name, _trait_name) = func_trait_name;
    let __ident = Ident::new(&format!("__{}", func_name), func_name.span());
    let __ident_no_lock = Ident::new(&format!("__{}_no_lock", func_name), func_name.span());
    let __ident_with_lock = Ident::new(&format!("__{}_with_lock", func_name), func_name.span());

    let TrampolineInfo {
        get_domain_id,
        check_code,
        call_move_to,
    } = info;

    let ident_call = quote!(
        // let r_domain = self.domain.get();
        // #check_code
        // #get_domain_id
        // #(#arg_domain_change)*
        // let res = r_domain.#func_name(#(#input_argv),*).map(|r| {
        //     #call_move_to
        //     r
        // });
        // res
        self.domain.read_directly(|domain|{
            #check_code
            #get_domain_id
            #(#arg_domain_change)*
            domain.#func_name(#(#input_argv),*).map(|r| {
                #call_move_to
                r
            })
        })
    );

    let inner_call = quote!(
        #[inline(always)]
        fn #__ident(&self, #(#fn_argv),*)#output{
            #ident_call
        }
        #[inline(always)]
        fn #__ident_no_lock(&self, #(#fn_argv),*)#output{
            self.counter.inc();
            let res = self.#__ident(#(#input_argv),*);
            self.counter.dec();
            res
        }
        #[cold]
        #[inline(always)]
        fn #__ident_with_lock(&self, #(#fn_argv),*)#output{
            // let r_lock = self.lock.read();
            let r_lock = loop {
                if let Some(r) = self.lock.try_read() {
                    break r;
                }else {
                    yield_now();
                }
            };
            let res = self.#__ident(#(#input_argv),*);
            drop(r_lock);
            res
        }
    );

    (inner_call, __ident_no_lock, __ident_with_lock)
}
```

TCB需要保存的信息
```Rust
#[derive(Debug, Default)]
pub struct DomainInfo {
    pub ty_list: BTreeMap<DomainTypeRaw, Vec<DomainFileInfo>>,
    pub domain_list: BTreeMap<u64, DomainDataInfo>,
}

#[derive(Debug, Clone)]
pub struct DomainDataInfo {
    pub name: String,
    pub ty: DomainTypeRaw,
    pub panic_count: usize,
    pub file_info: DomainFileInfo,
}

#[derive(Debug, Clone)]
pub struct DomainFileInfo {
    pub name: String,
    pub size: usize,
}

pub struct DomainResource {
    page_map: BTreeMap<u64, Vec<(usize, usize)>>,
    box_data: BTreeMap<u64, usize>,
}

struct SharedHeapAllocationPart {
    value_pointer: *mut u8,
    domain_id_pointer: *mut u64,
}
```